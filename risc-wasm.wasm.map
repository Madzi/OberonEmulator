{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","risc-wasm.ts"],"names":[],"mappings":"wdE4BC,AAAI,EAAM,EAAU,SACnB,AAAkB,AAAC,EAAK,EAAU,OAAY,KAC9C,AAAU,AAAW,EAAX,KACV,AAAgB,EAAhB,KACA,AAAY,EAAZ,KACA,AAAgB,EAAhB,KACA,AAAW,EAAX,MAED,AAAY,AAAC,EAAW,GAAU,KAAS,GAAQ,MACnD,KAQA,AAAW,EAAgB,EAAK,IAAG,KACnC,AAAS,KACT,AAAS,EAAQ,QAIjB,AAAQ,EAAW,KACnB,AAAI,IAAM,AAAe,EAAI,UAiB7B,AAAI,EAAW,KACd,AAAW,EAAU,GAAS,KACxB,AAAI,EAAW,KACrB,AAAgB,EAAU,GAAc,IACxC,AAAe,AAAC,EAAe,GAAgB,OAC1B,EAAI,KACxB,AAAoB,EAAG,AAAU,EAAW,GAAe,EAAI,SADlC,YAI9B,AAAW,AAAW,EAAX,GAAoB,KAC/B,AAAI,EAAW,KACd,AAAoB,AAAC,EAAU,GAAgB,GAAG,UAxBhD,AAAU,EAAW,KAArB,KACI,AAAU,EAAY,EAAU,QAC7B,EAAW,KACd,AAAU,EAAU,MACjB,EAAW,KACrB,AAAe,AAAW,SACnB,AAAe,EAAU,MAEzB,AAAU,AAAW,EAAX,iBAiClB,AAAc,AAAY,EAAQ,GAAG,MAErC,OAEA,AAAK,EAAK,SA4HH,AAAK,EAAK,SA6BhB,kBAAQ,AAAC,EAAO,GAAM,eACb,AAAI,OACJ,AAAI,OACJ,AAAI,OACJ,AAAI,OACJ,AAAI,EAAU,EAAV,QACJ,AAAI,EAAU,QACd,AAAI,EAAoB,EAApB,EAAU,SACd,AAAI,KAEb,AAAI,EAAM,AAAC,AAAC,EAAO,GAAM,GAAM,MAC9B,AAAK,EAAK,SACT,AAAe,EAAI,EAAQ,MAE5B,AAAK,EAAK,SAKT,AAAQ,AADF,EAAS,EAAK,OACL,EAAU,OAHzB,AAAQ,AArOX,AAAiB,EAAgB,AAoOR,EAAK,GApOQ,OAoOa,GACjC,EAAU,SA5C3B,AAAI,AAAC,EAAK,OAAe,KAIzB,AAAmB,AAAO,AA7L3B,AAAiB,EAAgB,AA0L3B,EAAK,MAAe,GA1LY,OA6LiB,AAFvC,AAAC,EAAK,KAAe,GAAM,IAEyB,KACnE,AAAK,EAAK,SAST,AAAK,EAAK,SAEH,AAAI,EAAU,KAGpB,AAFyB,AAIZ,EAAU,KAJgB,IAElC,AAAE,GAAQ,AADE,AAAC,EAAU,GAAK,YAGjC,AAAa,EAAc,AAD3B,EAAK,AAAC,AA7MT,AAAiB,EAAgB,EAAK,OA6MT,IAAS,OAGnC,AAAa,EAAU,GAAI,AAhN9B,AAAiB,EAAgB,EAAK,OAgNY,QAR/C,AAAa,EAxMhB,AAAiB,EAAgB,EAAK,WA+L/B,EAAK,SAGD,AAAC,AAAY,EAAU,GAAI,IAAY,AAAC,EAAU,GAAK,IAAM,KAF7D,AAAY,EAAS,OAI9B,AAAmB,IACnB,AAAe,EAAG,OAxInB,AAAI,AAAC,EAAK,OAAe,KAEzB,AAAc,AAAC,EAAK,KAAe,KACnC,AAAc,EAAK,OACnB,AAAa,EAAK,KAGlB,AApED,AAAiB,EAAgB,AA8D3B,EAAK,MAAe,GA9DY,SAqErC,AAAK,EAAK,SAEH,AAGE,AAAa,EAAb,OAHG,EAAK,SAvElB,AAAiB,EAAgB,EAAK,UA4ErC,kCAAQ,sBAEN,AAEO,AACE,EAAS,GACX,AACE,AACN,AAAS,MAAa,EAAtB,GADM,IAEN,AAAS,MAAa,EAAtB,IACA,AAAS,MAAa,EAAtB,IACA,AAAS,MAAa,EAAtB,IAEM,EAPG,EAAK,QAFL,EAAK,QADR,EADJ,EAAK,aAgBV,AAAQ,EAAU,QAIlB,AAAQ,AAAC,EAAW,QAIpB,AAAQ,AAA4B,EAAU,EAAC,IAAtC,EAAW,SAIpB,AAAQ,AAAQ,EAAR,QAIR,AAAQ,EAAQ,AAAC,WAIjB,AAAQ,AAAQ,EAAR,QAIR,AAAQ,AAAQ,EAAR,QAQR,AAAS,AAAC,AAHV,AACS,AAAC,AAFF,AAAS,EAAR,KAES,KADd,AAAoB,IAAnB,EAAK,WAGe,KACzB,AAAS,AAAC,AAAC,AAAE,AAAQ,EAAR,MAAkB,EAAQ,IAAY,GAAO,QAQ1D,AAAS,AAAC,AAHV,AACS,AAAC,AAFF,AAAC,EAAQ,KAEC,KADd,AAAoB,IAAnB,EAAK,WAGe,KACzB,AAAS,AAAC,AAAC,AAAC,AAAQ,EAAR,GAAkB,EAAQ,IAAY,GAAO,QAUzD,AAAQ,AALR,AAGO,AAAsB,EAAf,MAFP,GADF,EAAK,aAMV,AAAO,AAAO,EAAc,SAI5B,AAAK,EAAK,SAST,AAAQ,AAAC,EAAe,KACxB,AAAO,AAAC,EAAe,MARvB,AAAQ,EAAQ,KAKhB,AAJA,AAAI,AAFc,EAAQ,KAEd,KAEX,OADS,EAAT,aAWF,EAAS,UAMR,AADD,AACS,AAAiB,IAH1B,AACS,AAAiB,AAAiB,GAAS,AAAiB,OADjE,EAAoB,AAAC,EAAK,UAAzB,EAAK,WAEN,AAAwC,EAAS,WAAjD,AAAoB,AAAC,KAApB,OAEL,AAAI,AAAwC,IAAxC,EAAqB,EAApB,MACJ,AAAQ,AAAsB,UAG/B,AAAQ,AAAiB,AAAiB,GAAS,AAAiB,UAGpE,AAAQ,AAAiB,AAAiB,GAAS,AAAiB,QAGtE,AAAe,EAAG,YA1IE,AAAc,EAAa,KAA3B,EAAI,QACxB,EADoD,AAAE,cAkMvD,AAAoB,EAAkB,OAItC,KAIA,KAIA,AAAa,OAIb,KAIA","sourceRoot":"./risc-wasm.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","// This is AssemblyScript; you can compile it to WebAssembly on https://webassembly.studio/\r\n\r\ndeclare function memReadPalette(address0: i32): i32;\r\ndeclare function memWritePalette(address0: i32, val: i32): void;\r\ndeclare function memReadIO(address0: i32): i32;\r\ndeclare function memWriteIO(address0: i32, val: i32): void;\r\ndeclare function registerVideoChange(offset: i32, val: i32): void;\r\n\r\nconst REGISTER_BASE: usize = __heap_base;\r\nconst ROM_BASE: usize = REGISTER_BASE + 16 * 4;\r\nconst RAM_BASE: usize = ROM_BASE + 1024;\r\n\r\nvar flag_Z: bool = false;\r\nvar flag_N: bool = false;\r\nvar flag_C: bool = false;\r\nvar flag_V: bool = false;\r\nvar regPC: i32 = 0;\r\nvar regH: i32 = 0;\r\n\r\nvar ROMStart: i32 = 0x0FE000;\r\nvar DisplayStart: i32 = 0x0E7F00;\r\nvar PaletteStart: i32 = 0x0FFF80;\r\nvar IOStart: i32 = 0x0FFFC0;\r\nvar MemSize: i32 = 0x100000;\r\nvar waitMillis: i32 = 0;\r\nvar lastLoadRegister: i32 = 0;\r\n\r\nexport function Initialize(mb: i32): i32 {\r\n\tif (mb != MemSize / 0x100000) {\r\n\t\tvar offset: i32 = (mb - MemSize / 0x100000) * 0x100000;\r\n\t\tMemSize = 0x100000 * mb;\r\n\t\tDisplayStart += offset;\r\n\t\tROMStart += offset;\r\n\t\tPaletteStart += offset;\r\n\t\tIOStart += offset;\r\n\t}\r\n\tmemory.grow((RAM_BASE + MemSize + 65535) / 65536 - memory.size());\r\n\treturn ROM_BASE;\r\n}\r\n\r\nfunction cpuGetRegister(id: i32): i32 {\r\n\treturn load<i32>(REGISTER_BASE + id * 4);\r\n}\r\n\r\nfunction cpuPutRegister(id: i32, value: i32): void {\r\n\tstore<i32>(REGISTER_BASE + id * 4, value);\r\n\tflag_Z = value == 0;\r\n\tflag_N = value < 0;\r\n}\r\n\r\nexport function cpuReset(cold: bool): void {\r\n\tregPC = ROMStart / 4;\r\n\tif (cold) cpuPutRegister(15, 0);\r\n}\r\n\r\nfunction memReadWord(address: i32, mapROM: bool): i32 {\r\n\tif (mapROM && address >= ROMStart) {\r\n\t\treturn load<i32>(ROM_BASE + (address - ROMStart));\r\n\t} else if (address >= IOStart) {\r\n\t\treturn memReadIO(address - IOStart);\r\n\t} else if (address >= PaletteStart) {\r\n\t\tDisplayStart = 0x09FF00 + MemSize - 0x100000;\r\n\t\treturn memReadPalette(address - PaletteStart);\r\n\t} else {\r\n\t\treturn load<i32>(RAM_BASE + address);\r\n\t}\r\n}\r\n\r\nexport function memWriteWord(address: i32, value: i32): void {\r\n\tif (address >= IOStart) {\r\n\t\tmemWriteIO(address - IOStart, value);\r\n\t} else if (address >= PaletteStart) {\r\n\t\tmemWritePalette(address - PaletteStart, value);\r\n\t\tvar max: i32 = (PaletteStart - DisplayStart) / 4;\r\n\t\tfor (var i: i32 = 0; i < max; i++) {\r\n\t\t\tregisterVideoChange(i, load<i32>(RAM_BASE + DisplayStart + i * 4));\r\n\t\t}\r\n\t} else {\r\n\t\tstore<i32>(RAM_BASE + address, value);\r\n\t\tif (address >= DisplayStart) {\r\n\t\t\tregisterVideoChange((address - DisplayStart) / 4, value);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function cpuRun0(now: i32): void {\r\n\tfor (var i: i32 = 0; i < 200000 && waitMillis < now; ++i) {\r\n\t\tcpuSingleStep();\r\n\t}\r\n}\r\n\r\nexport function cpuSingleStep(): void {\r\n\tconst pbit: i32 = 0x80000000;\r\n\tconst qbit: i32 = 0x40000000;\r\n\tconst ubit: i32 = 0x20000000;\r\n\tconst vbit: i32 = 0x10000000;\r\n\r\n\tvar ir: i32 = memReadWord(regPC * 4, true);\r\n\tvar a_val: i32, a: i32, b: i32, pos: i32;\r\n\tregPC++;\r\n\r\n\tif ((ir & pbit) == 0) {\r\n\t\ta = (ir & 0x0F000000) >> 24;\r\n\t\tb = (ir & 0x00F00000) >> 20;\r\n\t\tvar op: i32 = (ir & 0x000F0000) >> 16;\r\n\t\tvar im: i32 = ir & 0x0000FFFF;\r\n\t\tvar c: i32 = ir & 0x0000000F;\r\n\r\n\t\tvar b_val: i32, c_val: i32;\r\n\t\tb_val = cpuGetRegister(b);\r\n\t\tif ((ir & qbit) == 0) {\r\n\t\t\tc_val = cpuGetRegister(c);\r\n\t\t} else if ((ir & vbit) == 0) {\r\n\t\t\tc_val = im;\r\n\t\t} else {\r\n\t\t\tc_val = 0xFFFF0000 | im;\r\n\t\t}\r\n\t\tswitch (op) {\r\n\t\t\tcase 0: {\r\n\t\t\t\tif ((ir & ubit) == 0) {\r\n\t\t\t\t\ta_val = c_val;\r\n\t\t\t\t} else if ((ir & qbit) != 0) {\r\n\t\t\t\t\ta_val = c_val << 16;\r\n\t\t\t\t} else if ((ir & vbit) != 0) {\r\n\t\t\t\t\ta_val = 0xD0 |\r\n\t\t\t\t\t\t(flag_N ? 0x80000000 : 0) |\r\n\t\t\t\t\t\t(flag_Z ? 0x40000000 : 0) |\r\n\t\t\t\t\t\t(flag_C ? 0x20000000 : 0) |\r\n\t\t\t\t\t\t(flag_V ? 0x10000000 : 0);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ta_val = regH;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 1: {\r\n\t\t\t\ta_val = b_val << (c_val & 31);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 2: {\r\n\t\t\t\ta_val = (b_val) >> (c_val & 31);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 3: {\r\n\t\t\t\ta_val = (b_val >>> (c_val & 31)) | (b_val << (-c_val & 31));\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 4: {\r\n\t\t\t\ta_val = b_val & c_val;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 5: {\r\n\t\t\t\ta_val = b_val & ~c_val;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 6: {\r\n\t\t\t\ta_val = b_val | c_val;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 7: {\r\n\t\t\t\ta_val = b_val ^ c_val;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 8: {\r\n\t\t\t\ta_val = (b_val + c_val) | 0;\r\n\t\t\t\tif ((ir & ubit) != 0 && flag_C) {\r\n\t\t\t\t\ta_val = (a_val + 1) | 0\r\n\t\t\t\t}\r\n\t\t\t\tflag_C = (<u32>a_val) < (<u32>b_val);\r\n\t\t\t\tflag_V = ((~(b_val ^ c_val) & (a_val ^ b_val)) >>> 31) != 0;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 9: {\r\n\t\t\t\ta_val = (b_val - c_val) | 0;\r\n\t\t\t\tif ((ir & ubit) != 0 && flag_C) {\r\n\t\t\t\t\ta_val = (a_val - 1) | 0;\r\n\t\t\t\t}\r\n\t\t\t\tflag_C = (<u32>a_val) > (<u32>b_val);\r\n\t\t\t\tflag_V = (((b_val ^ c_val) & (a_val ^ b_val)) >>> 31) != 0;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 10: {\r\n\t\t\t\tvar tmp: i64;\r\n\t\t\t\tif ((ir & ubit) == 0) {\r\n\t\t\t\t\ttmp = b_val * c_val;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttmp = <i64>((<u32>b_val) * (<u32>c_val));\r\n\t\t\t\t}\r\n\t\t\t\ta_val = <i32>tmp;\r\n\t\t\t\tregH = <i32>((<u64>tmp) >>> 32);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 11: {\r\n\t\t\t\tif ((ir & ubit) == 0) {\r\n\t\t\t\t\tvar h_val: i32 = (b_val % c_val);\r\n\t\t\t\t\ta_val = b_val / c_val;\r\n\t\t\t\t\tif (h_val < 0) {\r\n\t\t\t\t\t\th_val += c_val;\r\n\t\t\t\t\t\ta_val--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tregH = h_val;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ta_val = (<u32>b_val) / (<u32>c_val);\r\n\t\t\t\t\tregH = (<u32>b_val) % (<u32>c_val);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 13:\r\n\t\t\t\tc_val ^= 0x80000000;\r\n\t\t\t// fall through\r\n\t\t\tcase 12:\r\n\t\t\t\tif ((ir & ubit) == 0 && (ir & vbit) == 0)\r\n\t\t\t\t\ta_val = reinterpret<i32>(reinterpret<f32>(b_val) + reinterpret<f32>(c_val));\r\n\t\t\t\tif ((ir & ubit) != 0 && (ir & vbit) == 0 && c_val == 0x4B000000)\r\n\t\t\t\t\ta_val = reinterpret<i32>(<f32>b_val);\r\n\t\t\t\tif ((ir & ubit) == 0 && (ir & vbit) != 0 && c_val == 0x4B000000)\r\n\t\t\t\t\ta_val = <i32>reinterpret<f32>(b_val);\r\n\t\t\t\tbreak;\r\n\t\t\tcase 14:\r\n\t\t\t\ta_val = reinterpret<i32>(reinterpret<f32>(b_val) * reinterpret<f32>(c_val));\r\n\t\t\t\tbreak;\r\n\t\t\tcase 15:\r\n\t\t\t\ta_val = reinterpret<i32>(reinterpret<f32>(b_val) / reinterpret<f32>(c_val));\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\tcpuPutRegister(a, a_val);\r\n\t} else if ((ir & qbit) == 0) {\r\n\t\ta = (ir & 0x0F000000) >> 24;\r\n\t\tb = (ir & 0x00F00000) >> 20;\r\n\t\tvar off: i32 = (ir & 0x000FFFFF) << 12 >> 12;\r\n\r\n\t\tvar address: i32 = <i32>(((<u32>cpuGetRegister(b)) + (<u32>off)) % MemSize);\r\n\t\tif ((ir & ubit) == 0) {\r\n\t\t\tif ((ir & vbit) == 0) {\r\n\t\t\t\ta_val = memReadWord(address, false);\r\n\t\t\t} else {\r\n\t\t\t\ta_val = (memReadWord(address & ~3, false) >>> ((address % 4) * 8)) & 0xff;\r\n\t\t\t}\r\n\t\t\tlastLoadRegister = a;\r\n\t\t\tcpuPutRegister(a, a_val);\r\n\t\t} else {\r\n\t\t\tif ((ir & vbit) == 0) {\r\n\t\t\t\tmemWriteWord(address, cpuGetRegister(a));\r\n\t\t\t} else if (address < IOStart) {\r\n\t\t\t\tvar w: i32 = memReadWord(address & ~3, false);\r\n\t\t\t\tvar shift: i32 = (address & 3) * 8;\r\n\t\t\t\tw &= ~(0xFF << shift);\r\n\t\t\t\tw |= (cpuGetRegister(a) & 0xFF) << shift;\r\n\t\t\t\tmemWriteWord(address & ~3, w);\r\n\t\t\t} else {\r\n\t\t\t\tmemWriteWord(address & ~3, cpuGetRegister(a) & 0xFF);\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tvar t: bool;\r\n\t\tswitch ((ir >>> 24) & 7) {\r\n\t\t\tcase 0: t = flag_N; break;\r\n\t\t\tcase 1: t = flag_Z; break;\r\n\t\t\tcase 2: t = flag_C; break;\r\n\t\t\tcase 3: t = flag_V; break;\r\n\t\t\tcase 4: t = flag_C || flag_Z; break;\r\n\t\t\tcase 5: t = flag_N != flag_V; break;\r\n\t\t\tcase 6: t = flag_N != flag_V || flag_Z; break;\r\n\t\t\tcase 7: t = true; break;\r\n\t\t}\r\n\t\tif (t != (((ir >>> 24) & 8) != 0)) {\r\n\t\t\tif ((ir & vbit) != 0) {\r\n\t\t\t\tcpuPutRegister(15, regPC * 4);\r\n\t\t\t}\r\n\t\t\tif ((ir & ubit) == 0) {\r\n\t\t\t\tpos = (cpuGetRegister(ir & 0x0000000F) >>> 0) / 4;\r\n\t\t\t\tregPC = pos % (MemSize / 4);\r\n\t\t\t} else {\r\n\t\t\t\tpos = regPC + (ir & 0x00FFFFFF);\r\n\t\t\t\tregPC = pos % (MemSize / 4);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function repeatLastLoad(value: i32): void {\r\n\tthis.cpuPutRegister(lastLoadRegister, value);\r\n}\r\n\r\nexport function getRAMBase(): i32 {\r\n\treturn RAM_BASE;\r\n}\r\n\r\nexport function getRAMSize(): i32 {\r\n\treturn MemSize;\r\n}\r\n\r\nexport function setWaitMillis(val: i32): void {\r\n\twaitMillis = val;\r\n}\r\n\r\nexport function getDisplayStart(): i32 {\r\n\treturn DisplayStart;\r\n}\r\n\r\nexport function getWaitMillis(): i32 {\r\n\treturn waitMillis;\r\n}\r\n"]}