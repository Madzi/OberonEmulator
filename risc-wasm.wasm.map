{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","risc-wasm.ts"],"names":[],"mappings":"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","sourceRoot":"./risc-wasm.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                           GC info                             │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                          runtime id                           │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                         runtime size                          │ -4\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                              ...                              │ ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","// This is AssemblyScript; you can compile it to WebAssembly on https://webassembly.studio/\n\ndeclare function memReadPalette(address0: i32): i32;\ndeclare function memWritePalette(address0: i32, val: i32): void;\ndeclare function memReadIO(address0: i32): i32;\ndeclare function memWriteIO(address0: i32, val: i32): void;\ndeclare function registerVideoChange(offset: i32, val: i32): void;\n\nconst REGISTER_BASE: usize = __heap_base;\nconst ROM_BASE: usize = REGISTER_BASE + 16 * 4;\nconst RAM_BASE: usize = ROM_BASE + 1024;\n\nvar flag_Z: bool = false;\nvar flag_N: bool = false;\nvar flag_C: bool = false;\nvar flag_V: bool = false;\nvar regPC: i32 = 0;\nvar regH: i32 = 0;\n\nvar ROMStart: i32 = 0x0FE000;\nvar DisplayStart: i32 = 0x0E7F00;\nvar PaletteStart: i32 = 0x0FFF80;\nvar IOStart: i32 = 0x0FFFC0;\nvar MemSize: i32 = 0x100000;\nvar waitMillis: i32 = 0;\n\nexport function Initialize(mb: i32): i32 {\n\tif (mb != MemSize / 0x100000) {\n\t\tvar offset: i32 = (mb - MemSize / 0x100000) * 0x100000;\n\t\tMemSize = 0x100000 * mb;\n\t\tDisplayStart += offset;\n\t\tROMStart += offset;\n\t\tPaletteStart += offset;\n\t\tIOStart += offset;\n\t}\n\tmemory.grow((RAM_BASE + MemSize + 65535) / 65536 - memory.size());\n\treturn ROM_BASE;\n}\n\nfunction cpuGetRegister(id: i32): i32 {\n\treturn load<i32>(REGISTER_BASE + id * 4);\n}\n\nfunction cpuPutRegister(id: i32, value: i32): void {\n\tstore<i32>(REGISTER_BASE + id * 4, value);\n\tflag_Z = value == 0;\n\tflag_N = value < 0;\n}\n\nexport function cpuReset(cold: bool): void {\n\tregPC = ROMStart / 4;\n\tif (cold) cpuPutRegister(15, 0);\n}\n\nfunction memReadWord(address: i32, mapROM: bool): i32 {\n\tif (mapROM && address >= ROMStart) {\n\t\treturn load<i32>(ROM_BASE + (address - ROMStart));\n\t} else if (address >= IOStart) {\n\t\treturn memReadIO(address - IOStart);\n\t} else if (address >= PaletteStart) {\n\t\tDisplayStart = 0x09FF00 + MemSize - 0x100000;\n\t\treturn memReadPalette(address - PaletteStart);\n\t} else {\n\t\treturn load<i32>(RAM_BASE + address);\n\t}\n}\n\nexport function memWriteWord(address: i32, value: i32): void {\n\tif (address >= IOStart) {\n\t\tmemWriteIO(address - IOStart, value);\n\t} else if (address >= PaletteStart) {\n\t\tmemWritePalette(address - PaletteStart, value);\n\t\tvar max: i32 = (PaletteStart - DisplayStart) / 4;\n\t\tfor (var i: i32 = 0; i < max; i++) {\n\t\t\tregisterVideoChange(i, load<i32>(RAM_BASE + DisplayStart + i * 4));\n\t\t}\n\t} else {\n\t\tstore<i32>(RAM_BASE + address, value);\n\t\tif (address >= DisplayStart) {\n\t\t\tregisterVideoChange((address - DisplayStart) / 4, value);\n\t\t}\n\t}\n}\n\nexport function cpuRun0(now: i32): void {\n\tfor (var i: i32 = 0; i < 200000 && waitMillis < now; ++i) {\n\t\tcpuSingleStep();\n\t}\n}\n\nexport function cpuSingleStep(): void {\n\tconst pbit: i32 = 0x80000000;\n\tconst qbit: i32 = 0x40000000;\n\tconst ubit: i32 = 0x20000000;\n\tconst vbit: i32 = 0x10000000;\n\n\tvar ir: i32 = memReadWord(regPC * 4, true);\n\tvar a_val: i32, a: i32, b: i32, pos: i32;\n\tregPC++;\n\n\tif ((ir & pbit) == 0) {\n\t\ta = (ir & 0x0F000000) >> 24;\n\t\tb = (ir & 0x00F00000) >> 20;\n\t\tvar op: i32 = (ir & 0x000F0000) >> 16;\n\t\tvar im: i32 = ir & 0x0000FFFF;\n\t\tvar c: i32 = ir & 0x0000000F;\n\n\t\tvar b_val: i32, c_val: i32;\n\t\tb_val = cpuGetRegister(b);\n\t\tif ((ir & qbit) == 0) {\n\t\t\tc_val = cpuGetRegister(c);\n\t\t} else if ((ir & vbit) == 0) {\n\t\t\tc_val = im;\n\t\t} else {\n\t\t\tc_val = 0xFFFF0000 | im;\n\t\t}\n\t\tswitch (op) {\n\t\t\tcase 0: {\n\t\t\t\tif ((ir & ubit) == 0) {\n\t\t\t\t\ta_val = c_val;\n\t\t\t\t} else if ((ir & qbit) != 0) {\n\t\t\t\t\ta_val = c_val << 16;\n\t\t\t\t} else if ((ir & vbit) != 0) {\n\t\t\t\t\ta_val = 0xD0 |\n\t\t\t\t\t\t(flag_N ? 0x80000000 : 0) |\n\t\t\t\t\t\t(flag_Z ? 0x40000000 : 0) |\n\t\t\t\t\t\t(flag_C ? 0x20000000 : 0) |\n\t\t\t\t\t\t(flag_V ? 0x10000000 : 0);\n\t\t\t\t} else {\n\t\t\t\t\ta_val = regH;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 1: {\n\t\t\t\ta_val = b_val << (c_val & 31);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\ta_val = (b_val) >> (c_val & 31);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 3: {\n\t\t\t\ta_val = (b_val >>> (c_val & 31)) | (b_val << (-c_val & 31));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 4: {\n\t\t\t\ta_val = b_val & c_val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 5: {\n\t\t\t\ta_val = b_val & ~c_val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 6: {\n\t\t\t\ta_val = b_val | c_val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 7: {\n\t\t\t\ta_val = b_val ^ c_val;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 8: {\n\t\t\t\ta_val = (b_val + c_val) | 0;\n\t\t\t\tif ((ir & ubit) != 0 && flag_C) {\n\t\t\t\t\ta_val = (a_val + 1) | 0\n\t\t\t\t}\n\t\t\t\tflag_C = (<u32>a_val) < (<u32>b_val);\n\t\t\t\tflag_V = ((~(b_val ^ c_val) & (a_val ^ b_val)) >>> 31) != 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 9: {\n\t\t\t\ta_val = (b_val - c_val) | 0;\n\t\t\t\tif ((ir & ubit) != 0 && flag_C) {\n\t\t\t\t\ta_val = (a_val - 1) | 0;\n\t\t\t\t}\n\t\t\t\tflag_C = (<u32>a_val) > (<u32>b_val);\n\t\t\t\tflag_V = (((b_val ^ c_val) & (a_val ^ b_val)) >>> 31) != 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 10: {\n\t\t\t\tvar tmp: i64;\n\t\t\t\tif ((ir & ubit) == 0) {\n\t\t\t\t\ttmp = b_val * c_val;\n\t\t\t\t} else {\n\t\t\t\t\ttmp = <i64>((<u32>b_val) * (<u32>c_val));\n\t\t\t\t}\n\t\t\t\ta_val = <i32>tmp;\n\t\t\t\tregH = <i32>((<u64>tmp) >>> 32);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 11: {\n\t\t\t\tif ((ir & ubit) == 0) {\n\t\t\t\t\tvar h_val: i32 = (b_val % c_val);\n\t\t\t\t\ta_val = b_val / c_val;\n\t\t\t\t\tif (h_val < 0) {\n\t\t\t\t\t\th_val += c_val;\n\t\t\t\t\t\ta_val--;\n\t\t\t\t\t}\n\t\t\t\t\tregH = h_val;\n\t\t\t\t} else {\n\t\t\t\t\ta_val = (<u32>b_val) / (<u32>c_val);\n\t\t\t\t\tregH = (<u32>b_val) % (<u32>c_val);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 13:\n\t\t\t\tc_val ^= 0x80000000;\n\t\t\t// fall through\n\t\t\tcase 12:\n\t\t\t\tif ((ir & ubit) == 0 && (ir & vbit) == 0)\n\t\t\t\t\ta_val = reinterpret<i32>(reinterpret<f32>(b_val) + reinterpret<f32>(c_val));\n\t\t\t\tif ((ir & ubit) != 0 && (ir & vbit) == 0 && c_val == 0x4B000000)\n\t\t\t\t\ta_val = reinterpret<i32>(<f32>b_val);\n\t\t\t\tif ((ir & ubit) == 0 && (ir & vbit) != 0 && c_val == 0x4B000000)\n\t\t\t\t\ta_val = <i32>reinterpret<f32>(b_val);\n\t\t\t\tbreak;\n\t\t\tcase 14:\n\t\t\t\ta_val = reinterpret<i32>(reinterpret<f32>(b_val) * reinterpret<f32>(c_val));\n\t\t\t\tbreak;\n\t\t\tcase 15:\n\t\t\t\ta_val = reinterpret<i32>(reinterpret<f32>(b_val) / reinterpret<f32>(c_val));\n\t\t\t\tbreak;\n\t\t}\n\t\tcpuPutRegister(a, a_val);\n\t} else if ((ir & qbit) == 0) {\n\t\ta = (ir & 0x0F000000) >> 24;\n\t\tb = (ir & 0x00F00000) >> 20;\n\t\tvar off: i32 = (ir & 0x000FFFFF) << 12 >> 12;\n\n\t\tvar address: i32 = <i32>(((<u32>cpuGetRegister(b)) + (<u32>off)) % MemSize);\n\t\tif ((ir & ubit) == 0) {\n\t\t\tif ((ir & vbit) == 0) {\n\t\t\t\ta_val = memReadWord(address, false);\n\t\t\t} else {\n\t\t\t\ta_val = (memReadWord(address & ~3, false) >>> ((address % 4) * 8)) & 0xff;\n\t\t\t}\n\t\t\tcpuPutRegister(a, a_val);\n\t\t} else {\n\t\t\tif ((ir & vbit) == 0) {\n\t\t\t\tmemWriteWord(address, cpuGetRegister(a));\n\t\t\t} else if (address < IOStart) {\n\t\t\t\tvar w: i32 = memReadWord(address & ~3, false);\n\t\t\t\tvar shift: i32 = (address & 3) * 8;\n\t\t\t\tw &= ~(0xFF << shift);\n\t\t\t\tw |= (cpuGetRegister(a) & 0xFF) << shift;\n\t\t\t\tmemWriteWord(address & ~3, w);\n\t\t\t} else {\n\t\t\t\tmemWriteWord(address & ~3, cpuGetRegister(a) & 0xFF);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvar t: bool;\n\t\tswitch ((ir >>> 24) & 7) {\n\t\t\tcase 0: t = flag_N; break;\n\t\t\tcase 1: t = flag_Z; break;\n\t\t\tcase 2: t = flag_C; break;\n\t\t\tcase 3: t = flag_V; break;\n\t\t\tcase 4: t = flag_C || flag_Z; break;\n\t\t\tcase 5: t = flag_N != flag_V; break;\n\t\t\tcase 6: t = flag_N != flag_V || flag_Z; break;\n\t\t\tcase 7: t = true; break;\n\t\t}\n\t\tif (t != (((ir >>> 24) & 8) != 0)) {\n\t\t\tif ((ir & vbit) != 0) {\n\t\t\t\tcpuPutRegister(15, regPC * 4);\n\t\t\t}\n\t\t\tif ((ir & ubit) == 0) {\n\t\t\t\tpos = (cpuGetRegister(ir & 0x0000000F) >>> 0) / 4;\n\t\t\t\tregPC = pos % (MemSize / 4);\n\t\t\t} else {\n\t\t\t\tpos = regPC + (ir & 0x00FFFFFF);\n\t\t\t\tregPC = pos % (MemSize / 4);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function getRAMBase(): i32 {\n\treturn RAM_BASE;\n}\n\nexport function getRAMSize(): i32 {\n\treturn MemSize;\n}\n\nexport function setWaitMillis(val: i32): void {\n\twaitMillis = val;\n}\n\nexport function getDisplayStart(): i32 {\n\treturn DisplayStart;\n}\n\nexport function getWaitMillis(): i32 {\n\treturn waitMillis;\n}\n"]}